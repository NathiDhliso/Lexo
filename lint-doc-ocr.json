(node:42788) [DEP0190] DeprecationWarning: Passing args to a child process with shell option true can lead to security vulnerabilities, as the arguments are not escaped, only concatenated.
(Use `node --trace-deprecation ...` to show where the warning was created)
[{"filePath":"C:\\Users\\nathi\\Downloads\\LexoHub\\src\\services\\ai\\document-ocr.service.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'preprocessedData' is defined but never used.","line":206,"column":43,"nodeType":null,"messageId":"unusedVar","endLine":206,"endColumn":59}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Advanced Document OCR Service\r\n * Handles optical character recognition, document structure analysis, and text extraction\r\n */\r\n\r\nimport { toast } from 'react-hot-toast';\r\nimport { AdvancedNLPService, type LegalDocumentAnalysis } from './nlp-processor.service';\r\n\r\nexport interface OCRResult {\r\n  id: string;\r\n  text: string;\r\n  confidence: number;\r\n  pages: OCRPage[];\r\n  structuredData: DocumentStructure;\r\n  processingTime: number;\r\n  metadata: {\r\n    fileType: string;\r\n    fileSize: number;\r\n    pageCount: number;\r\n    language: string;\r\n    orientation: number;\r\n  };\r\n}\r\n\r\nexport interface OCRPage {\r\n  pageNumber: number;\r\n  text: string;\r\n  confidence: number;\r\n  boundingBoxes: BoundingBox[];\r\n  tables: TableStructure[];\r\n  images: ImageRegion[];\r\n}\r\n\r\nexport interface BoundingBox {\r\n  text: string;\r\n  confidence: number;\r\n  coordinates: {\r\n    x: number;\r\n    y: number;\r\n    width: number;\r\n    height: number;\r\n  };\r\n  type: 'word' | 'line' | 'paragraph' | 'title' | 'header' | 'footer';\r\n}\r\n\r\nexport interface TableStructure {\r\n  rows: number;\r\n  columns: number;\r\n  cells: TableCell[][];\r\n  confidence: number;\r\n  boundingBox: BoundingBox['coordinates'];\r\n}\r\n\r\nexport interface TableCell {\r\n  text: string;\r\n  confidence: number;\r\n  rowSpan: number;\r\n  colSpan: number;\r\n  coordinates: BoundingBox['coordinates'];\r\n}\r\n\r\nexport interface ImageRegion {\r\n  type: 'signature' | 'stamp' | 'logo' | 'chart' | 'photo' | 'drawing';\r\n  confidence: number;\r\n  coordinates: BoundingBox['coordinates'];\r\n  description?: string;\r\n}\r\n\r\nexport interface DocumentStructure {\r\n  title?: string;\r\n  headers: string[];\r\n  paragraphs: string[];\r\n  lists: Array<{\r\n    type: 'numbered' | 'bulleted';\r\n    items: string[];\r\n  }>;\r\n  signatures: Array<{\r\n    type: 'handwritten' | 'digital';\r\n    signatory?: string;\r\n    date?: string;\r\n    coordinates: BoundingBox['coordinates'];\r\n  }>;\r\n  footnotes: string[];\r\n  references: Array<{\r\n    type: 'case' | 'statute' | 'regulation';\r\n    text: string;\r\n    pageNumber: number;\r\n  }>;\r\n}\r\n\r\nexport interface DocumentProcessingRequest {\r\n  fileId: string;\r\n  fileName: string;\r\n  fileType: string;\r\n  analysisType: 'basic' | 'legal' | 'financial' | 'comprehensive';\r\n  extractTables: boolean;\r\n  extractImages: boolean;\r\n  languages: string[];\r\n  enhanceQuality: boolean;\r\n}\r\n\r\nexport interface DocumentProcessingResult {\r\n  ocrResult: OCRResult;\r\n  legalAnalysis?: LegalDocumentAnalysis;\r\n  extractedData: {\r\n    parties: Array<{ name: string; role: string; address?: string }>;\r\n    dates: Array<{ date: string; type: string; description: string }>;\r\n    amounts: Array<{ amount: number; currency: string; description: string }>;\r\n    references: Array<{ type: string; citation: string; relevance: number }>;\r\n  };\r\n  qualityMetrics: {\r\n    overallConfidence: number;\r\n    textClarity: number;\r\n    structureDetection: number;\r\n    entityExtraction: number;\r\n  };\r\n}\r\n\r\nexport class AdvancedOCRService {\r\n  private static readonly API_ENDPOINTS = {\r\n    // In production, these would be actual cloud service endpoints\r\n    AZURE_DOCUMENT_INTELLIGENCE: 'https://api.cognitive.microsoft.com/documentintelligence/v1.0',\r\n    GOOGLE_DOCUMENT_AI: 'https://documentai.googleapis.com/v1',\r\n    AWS_TEXTRACT: 'https://textract.amazonaws.com'\r\n  };\r\n\r\n  private static readonly SUPPORTED_FORMATS = [\r\n    'application/pdf',\r\n    'image/jpeg',\r\n    'image/png',\r\n    'image/tiff',\r\n    'application/msword',\r\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.document'\r\n  ];\r\n\r\n  /**\r\n   * Process document with advanced OCR and analysis\r\n   */\r\n  static async processDocument(request: DocumentProcessingRequest): Promise<DocumentProcessingResult> {\r\n    try {\r\n      const startTime = Date.now();\r\n      \r\n      // Validate file format\r\n      if (!this.SUPPORTED_FORMATS.includes(request.fileType)) {\r\n        throw new Error(`Unsupported file format: ${request.fileType}`);\r\n      }\r\n\r\n      // Step 1: Preprocess document for better OCR results\r\n      const preprocessedData = await this.preprocessDocument(request);\r\n      \r\n      // Step 2: Extract text using OCR\r\n      const ocrResult = await this.extractTextWithOCR(preprocessedData);\r\n      \r\n      // Step 3: Perform structure analysis\r\n      const structuredData = await this.analyzeDocumentStructure(ocrResult);\r\n      \r\n      // Step 4: Extract legal entities and data\r\n      const extractedData = await this.extractStructuredData(ocrResult.text);\r\n      \r\n      // Step 5: Perform legal analysis if requested\r\n      let legalAnalysis: LegalDocumentAnalysis | undefined;\r\n      if (request.analysisType === 'legal' || request.analysisType === 'comprehensive') {\r\n        legalAnalysis = await AdvancedNLPService.analyzeLegalDocument(ocrResult.text);\r\n      }\r\n\r\n      // Step 6: Calculate quality metrics\r\n      const qualityMetrics = this.calculateQualityMetrics(ocrResult, extractedData);\r\n\r\n      const processingTime = Date.now() - startTime;\r\n\r\n      return {\r\n        ocrResult: {\r\n          ...ocrResult,\r\n          structuredData,\r\n          processingTime\r\n        },\r\n        legalAnalysis,\r\n        extractedData,\r\n        qualityMetrics\r\n      };\r\n    } catch (error) {\r\n      console.error('Error processing document:', error);\r\n      throw new Error('Failed to process document with OCR');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Preprocess document for optimal OCR results\r\n   */\r\n  private static async preprocessDocument(request: DocumentProcessingRequest) {\r\n    // Simulate preprocessing steps that would happen in production\r\n    console.log('Preprocessing document:', request.fileName);\r\n    \r\n    return {\r\n      fileId: request.fileId,\r\n      enhancedQuality: request.enhanceQuality,\r\n      orientation: 0, // Would detect and correct orientation\r\n      resolution: 300, // Would enhance to optimal DPI\r\n      cleaned: true // Would remove noise, correct skew, etc.\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract text using advanced OCR\r\n   */\r\n  private static async extractTextWithOCR(preprocessedData: Record<string, unknown>): Promise<OCRResult> {\r\n    // No mock OCR output. Return an empty result until a provider is configured.\r\n      toast('OCR provider not configured. Returning empty extraction.', { icon: 'Γä╣∩╕Å' });\r\n    return {\r\n      id: `ocr-${Date.now()}`,\r\n      text: '',\r\n      confidence: 0,\r\n      pages: [],\r\n      structuredData: {} as DocumentStructure,\r\n      processingTime: 0,\r\n      metadata: {\r\n        fileType: 'unknown',\r\n        fileSize: 0,\r\n        pageCount: 0,\r\n        language: 'en',\r\n        orientation: 0\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Analyze document structure\r\n   */\r\n  private static async analyzeDocumentStructure(ocrResult: OCRResult): Promise<DocumentStructure> {\r\n    const text = ocrResult.text;\r\n    const lines = text.split('\\n').filter(line => line.trim());\r\n    \r\n    // Extract title (usually first significant line)\r\n    const title = lines.find(line => \r\n      line.trim().length > 5 && \r\n      !line.includes('Case No:') && \r\n      !line.includes('In the matter')\r\n    )?.trim();\r\n\r\n    // Extract headers (lines in ALL CAPS or with specific patterns)\r\n    const headers = lines.filter(line => {\r\n      const trimmed = line.trim();\r\n      return trimmed.length > 3 && \r\n             (trimmed === trimmed.toUpperCase() || \r\n              /^(TO:|TAKE NOTICE|DATED)/.test(trimmed));\r\n    });\r\n\r\n    // Extract paragraphs (numbered or lettered items)\r\n    const paragraphs = lines.filter(line => {\r\n      const trimmed = line.trim();\r\n      return /^\\d+\\./.test(trimmed) || trimmed.length > 50;\r\n    });\r\n\r\n    // Extract numbered lists\r\n    const numberedItems = lines.filter(line => /^\\d+\\./.test(line.trim()));\r\n    const lists = numberedItems.length > 0 ? [{\r\n      type: 'numbered' as const,\r\n      items: numberedItems\r\n    }] : [];\r\n\r\n    // Look for signatures (lines with dates and names)\r\n    const signatures = lines\r\n      .filter(line => /DATED|Attorney|Advocate/.test(line))\r\n      .map(line => ({\r\n        type: 'handwritten' as const,\r\n        signatory: this.extractSignatory(line),\r\n        date: this.extractDate(line),\r\n        coordinates: { x: 0, y: 0, width: 100, height: 20 }\r\n      }));\r\n\r\n    // Extract case references\r\n    const references = lines\r\n      .filter(line => /Case No:|v\\.|vs\\.|Appeal/.test(line))\r\n      .map(line => ({\r\n        type: 'case' as const,\r\n        text: line.trim(),\r\n        pageNumber: 1\r\n      }));\r\n\r\n    return {\r\n      title,\r\n      headers,\r\n      paragraphs,\r\n      lists,\r\n      signatures,\r\n      footnotes: [],\r\n      references\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract structured data from OCR text\r\n   */\r\n  private static async extractStructuredData(text: string) {\r\n    // Use the NLP service to extract entities\r\n    const legalEntities = AdvancedNLPService.extractLegalEntities(text);\r\n    \r\n    return {\r\n      parties: legalEntities.parties.map(p => ({\r\n        name: p.name,\r\n        role: p.role,\r\n        address: this.extractAddress(text, p.name)\r\n      })),\r\n      dates: legalEntities.dates.map(d => ({\r\n        date: d.date,\r\n        type: this.classifyDateType(d.context),\r\n        description: d.context\r\n      })),\r\n      amounts: legalEntities.amounts.map(a => ({\r\n        amount: a.amount,\r\n        currency: a.currency,\r\n        description: a.context\r\n      })),\r\n      references: legalEntities.courtReferences.map(r => ({\r\n        type: 'court',\r\n        citation: r.court,\r\n        relevance: r.confidence\r\n      }))\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate quality metrics for OCR result\r\n   */\r\n  private static calculateQualityMetrics(ocrResult: OCRResult, extractedData: Record<string, unknown>) {\r\n    const textLength = ocrResult.text.length;\r\n    const entityCount = Object.values(extractedData).flat().length;\r\n    \r\n    return {\r\n      overallConfidence: ocrResult.confidence,\r\n      textClarity: Math.min(0.95, 0.7 + (textLength / 10000) * 0.25),\r\n      structureDetection: Math.min(0.9, 0.5 + (entityCount / 20) * 0.4),\r\n      entityExtraction: Math.min(0.88, 0.6 + (entityCount / 15) * 0.28)\r\n    };\r\n  }\r\n\r\n\r\n  /**\r\n   * Classify line type for OCR processing\r\n   */\r\n  private static classifyLineType(line: string): BoundingBox['type'] {\r\n    const trimmed = line.trim();\r\n    \r\n    if (trimmed === trimmed.toUpperCase() && trimmed.length > 10) {\r\n      return 'title';\r\n    }\r\n    if (/^(TO:|TAKE NOTICE|DATED)/.test(trimmed)) {\r\n      return 'header';\r\n    }\r\n    if (trimmed.length < 20) {\r\n      return 'word';\r\n    }\r\n    if (trimmed.length < 80) {\r\n      return 'line';\r\n    }\r\n    \r\n    return 'paragraph';\r\n  }\r\n\r\n  /**\r\n   * Extract signatory from signature line\r\n   */\r\n  private static extractSignatory(line: string): string | undefined {\r\n    const signatoryMatch = line.match(/([A-Z\\s&]+)$/);\r\n    return signatoryMatch ? signatoryMatch[1].trim() : undefined;\r\n  }\r\n\r\n  /**\r\n   * Extract date from text line\r\n   */\r\n  private static extractDate(line: string): string | undefined {\r\n    const dateMatch = line.match(/(\\d{1,2}(?:st|nd|rd|th)?\\s+day\\s+of\\s+\\w+\\s+\\d{4})/);\r\n    return dateMatch ? dateMatch[1] : undefined;\r\n  }\r\n\r\n  /**\r\n   * Extract address for a party\r\n   */\r\n  private static extractAddress(text: string, partyName: string): string | undefined {\r\n    // Simple address extraction - would be more sophisticated in production\r\n    const lines = text.split('\\n');\r\n    const partyIndex = lines.findIndex(line => line.includes(partyName));\r\n    \r\n    if (partyIndex >= 0 && partyIndex < lines.length - 1) {\r\n      const nextLine = lines[partyIndex + 1];\r\n      if (nextLine && /\\d/.test(nextLine)) {\r\n        return nextLine.trim();\r\n      }\r\n    }\r\n    \r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Classify date type based on context\r\n   */\r\n  private static classifyDateType(context: string): string {\r\n    const lowerContext = context.toLowerCase();\r\n    \r\n    if (lowerContext.includes('dated') || lowerContext.includes('signed')) {\r\n      return 'execution';\r\n    }\r\n    if (lowerContext.includes('hearing') || lowerContext.includes('court')) {\r\n      return 'hearing';\r\n    }\r\n    if (lowerContext.includes('deadline') || lowerContext.includes('file')) {\r\n      return 'deadline';\r\n    }\r\n    \r\n    return 'general';\r\n  }\r\n\r\n  /**\r\n   * Batch process multiple documents\r\n   */\r\n  static async batchProcessDocuments(requests: DocumentProcessingRequest[]): Promise<DocumentProcessingResult[]> {\r\n    const results = [];\r\n    \r\n    for (const request of requests) {\r\n      try {\r\n        const result = await this.processDocument(request);\r\n        results.push(result);\r\n      } catch (error) {\r\n        console.error(`Error processing document ${request.fileName}:`, error);\r\n        // Continue with other documents\r\n      }\r\n    }\r\n    \r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Get processing capabilities\r\n   */\r\n  static getCapabilities() {\r\n    return {\r\n      supportedFormats: this.SUPPORTED_FORMATS,\r\n      maxFileSize: 50 * 1024 * 1024, // 50MB\r\n      maxPages: 100,\r\n      languages: ['en', 'af', 'zu', 'xh'], // South African languages\r\n      features: {\r\n        textExtraction: true,\r\n        tableExtraction: true,\r\n        imageExtraction: true,\r\n        structureAnalysis: true,\r\n        legalAnalysis: true,\r\n        handwritingRecognition: true,\r\n        signatureDetection: true\r\n      }\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[]}]
